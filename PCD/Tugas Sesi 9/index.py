# -*- coding: utf-8 -*-
"""Tugas 1 PCD Setelah UTS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10L_k6j25zaLi8IrZLZ3nCQ724Xrp4bn6

# Tugas 1 PCD Setelah UTS

Vincentius Johanes Lwie Jaya // 233408010

Buat percobaan dengan:

- Otsu
- Canny
- Edge Matching
- Watersheed
- Hough

`Requirement Library :`
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

"""`Import Image :`"""

image = cv2.imread('/bochii.jpeg', cv2.IMREAD_GRAYSCALE)

"""## 1. OTSU

### FULL CODE
"""

# Otsu's thresholding
_, otsu_thresh = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Tampilkan hasil
plt.figure(figsize=(10, 5))
plt.subplot(121), plt.imshow(image, cmap='gray'), plt.title('Original')
plt.subplot(122), plt.imshow(otsu_thresh, cmap='gray'), plt.title('Otsu Thresholding')
plt.show()

"""## 2. CANNY

### FULL CODE
"""

# Canny edge detection
edges = cv2.Canny(image, 100, 200)  # Threshold bisa disesuaikan

# Tampilkan hasil
plt.figure(figsize=(10, 5))
plt.subplot(121), plt.imshow(image, cmap='gray'), plt.title('Original')
plt.subplot(122), plt.imshow(edges, cmap='gray'), plt.title('Canny Edges')
plt.show()

"""## 3. EDGE

### FULL CODE
"""

# Sobel Edge Detection
sobelx = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5)
sobely = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5)
sobel_combined = np.sqrt(sobelx**2 + sobely**2)

# Tampilkan hasil
plt.figure(figsize=(15, 5))
plt.subplot(131), plt.imshow(sobelx, cmap='gray'), plt.title('Sobel X')
plt.subplot(132), plt.imshow(sobely, cmap='gray'), plt.title('Sobel Y')
plt.subplot(133), plt.imshow(sobel_combined, cmap='gray'), plt.title('Sobel Combined')
plt.show()

"""## 4. MATCHING

### FULL CODE
"""

template = cv2.imread('/bochi.jpeg', 0)  # Pastikan ukuran lebih kecil

# Template Matching
res = cv2.matchTemplate(image, template, cv2.TM_CCOEFF_NORMED)
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)

# Gambar bounding box
img_display = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
top_left = max_loc
h, w = template.shape
bottom_right = (top_left[0] + w, top_left[1] + h)
cv2.rectangle(img_display, top_left, bottom_right, (0, 255, 0), 2)

# Tampilkan hasil
plt.figure(figsize=(15, 5))
plt.subplot(131), plt.imshow(template, cmap='gray'), plt.title('Template')
plt.subplot(132), plt.imshow(res, cmap='hot'), plt.title('Heatmap Matching')
plt.subplot(133), plt.imshow(img_display), plt.title('Lokasi Terdeteksi')
plt.show()

"""## 5. Watersheed

### FULL CODE
"""

gray = image

# Thresholding
_, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

# Noise removal
kernel = np.ones((3,3), np.uint8)
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)

# Area background pasti
sure_bg = cv2.dilate(opening, kernel, iterations=3)

# Transformasi jarak
dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
_, sure_fg = cv2.threshold(dist_transform, 0.7*dist_transform.max(), 255, 0)

# Area unknown
sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(sure_bg, sure_fg)

# Marker labelling
_, markers = cv2.connectedComponents(sure_fg)
markers = markers + 1
markers[unknown == 255] = 0

# Convert the grayscale image to BGR for watershed function
image_bgr = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)

# Watershed
markers = cv2.watershed(image_bgr, markers)
image_bgr[markers == -1] = [255, 0, 0]  # Mark boundaries with red

# Tampilkan hasil
plt.figure(figsize=(10, 5))
# Convert the grayscale image to RGB for displaying with matplotlib
plt.subplot(121), plt.imshow(cv2.cvtColor(image, cv2.COLOR_GRAY2RGB)), plt.title('Original')
plt.subplot(122), plt.imshow(cv2.cvtColor(image_bgr, cv2.COLOR_BGR2RGB)), plt.title('Watershed Segmentation')
plt.show()

"""## 6. HOUGH

### FULL CODE
"""

gray = image

# Deteksi tepi
edges = cv2.Canny(gray, 50, 150, apertureSize=3)

# Hough Line Transform
lines = cv2.HoughLines(edges, 1, np.pi/180, 200)  # Parameter terakhir adalah threshold

# Gambar garis yang terdeteksi
if lines is not None:
    for line in lines:
        rho, theta = line[0]
        a = np.cos(theta)
        b = np.sin(theta)
        x0 = a * rho
        y0 = b * rho
        x1 = int(x0 + 1000*(-b))
        y1 = int(y0 + 1000*(a))
        x2 = int(x0 - 1000*(-b))
        y2 = int(y0 - 1000*(a))
        cv2.line(image, (x1, y1), (x2, y2), (0, 0, 255), 2)

# Tampilkan hasil
plt.figure(figsize=(10, 5))
plt.subplot(121), plt.imshow(edges, cmap='gray'), plt.title('Canny Edges')
plt.subplot(122), plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)), plt.title('Hough Lines')
plt.show()